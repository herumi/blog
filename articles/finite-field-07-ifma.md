---
title: "AVX-512 IFMAによる有限体の実装"
emoji: "🧮"
type: "tech"
topics: ["AVX512", "IFMA", "有限体"]
published: false
---
## 初めに

[有限体の実装](https://zenn.dev/herumi/articles/finite-field-01-add)では、主にx64向けの高速な実装方法を紹介してきました。
今回は、AVX-512 IFMA命令を使った実装方法を紹介します。

## AVX-512 IFMA
浮動小数点数におけるFMA (Fused Multiply-Add) は浮動小数点数 $a$, $b$, $c$ に対して $a b + c$ を計算する命令です。
AVX-512 IFMAはそれの整数版で、64ビット整数 $a$, $b$, $c$ に対して $a b + c$ を計算します。
ただし、$a$, $b$ は下位52ビットのみが利用され（$c$ は64ビット整数）、演算結果は最大104ビットです。
更に、上位52ビットと下位52ビットを別々に求める必要があります。

*AVX-512 IFMA*
命令|$a$, $b$, $c$ に対する演算
-|-
vpmadd52luq|`uint52_t(a * b) + c`
vpmadd52huq|`uint52_t((a * b) >> 52) + c`

$a$, $b$ が52ビットという中途半端なビットになっているのは、double の仮数部が52ビットで、その回路部分を流用しているのかなと想像します。
また、$a b + c$ の上位52ビット, 下位52ビットでは無いことにも注意してください。

## 52ビット2進数
AVX-512 IFMAを使った384ビット進数の有限体の実装をするには今までのCPUのビットサイズ (32 or 64) とは異なるやり方が必要です。
52ビット整数を64ビット整数に保持すると12ビットの隙間ができます。
384ビットの場合は `384 = 7 * 52 + 20` なので、64ビット整数を8個使い、7個には52ビットずつ、最後の1個に20ビットを格納します。各種演算は $2^{52}$ 進数（52ビット2進数）で行います。

*384ビット整数 $x$ を2進数表記 $[x_{383}:x_{382}:\cdots:x_0]$ して52ビット進数として格納する*
![](/images/52-bit-binary-number.png)

AVX-512 IFMAは512ビットSIMD幅なので、一つのレジスタに一つの384ビット整数を入れたくなりますが、そうすると並列処理が困難です。そのためZMMレジスタを8個用意し、8個の384ビット整数を分割して格納します。

*8個の384ビット整数 $x^{(0)}, \dots, x^{(7)}$ を8個のzmm0, ..., zmm7に格納する*
![](/images/52-bit-binary-number2.png)

## 加算
