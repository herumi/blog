# ビット操作あれこれ

## `x & -x`

```
for (int x = 0; x < 20; x++) {
    printf("%d %d\n", x, x & -x);
}
```
結果
```
0 0
1 1
2 2
3 1
4 4
5 1
6 2
7 1
8 8
9 1
10 2
11 1
12 4
13 1
14 2
15 1
16 16
17 1
18 2
19 1
```

### `x & -x`の役割

- LSB(一番小さい右のビット)から見て最初に1が立った部分のみ1にしてそれ以外は0にする
- 0のときは0

### 理由
- `-x = ~x + 1`である(intが2の補数のとき - x64やARMなど)
- `~x`はビット反転
- `+ 1`は1を足す

### 「1を足す」とは

```
0 000000
1 000001
2 000010
3 000011
4 000100
5 000101
6 000110
7 000111
8 001000
9 001001
...
```

- 右から0個以上連続する1(これを`1...1`と書く)の左に0があると見なす
  - `*01...1` ; *は任意個のなんでもよいビットパターン
  - 任意の値はこの形とみなせる
- `+1`はこれを`*10...0`に変換する操作
  - `0` → `1` ; 0個連続する1
  - `1` → `10` ; 1個連続する1
  - `011` → `100` ; 2個連続する1
  - `1...1`(全部1) → `0...0` ; 1はオーバーフローして消える

元のxを「*10...0」の形とみなす(0...0は0個以上連続する0なので任意のxはこの形とみなせる)

- `x = *10...0`
- `~x = ~*01...1`
- `-x = ~x+1 = ~*10...0`
- `x & -x`
  - 上位ビットは`* & ~*`なので0
  - 下位ビットは`10...0`
  - よってLSBから見て最初に1が立った部分だけが残り、後は0

### blsi(x)

x86には`blsi(x) = x & -x`という命令がある(BMI1 : Haswell以降)

## ビット組み合わせのパターン

[サンプルコード](https://github.com/herumi/misc/blob/master/combination2.cpp)

```
uint64_t nextCombination(uint64_t a)
{
  uint64_t b = a ^ (a + 1);
  uint64_t c = a - b / 2;
  return c - (c & -c) / (b + 1);
}

int n = 5;
int k = 3;
int a = ((1 << (n - k)) - 1) << k; // 5個の内2個1が立っている
do {
  putB(n, a);
} while (a = nextCombination(a));
```

結果
```
       1: 1 1 0 0 0
       2: 1 0 1 0 0
       3: 1 0 0 1 0
       4: 1 0 0 0 1
       5: 0 1 1 0 0
       6: 0 1 0 1 0
       7: 0 1 0 0 1
       8: 0 0 1 1 0
       9: 0 0 1 0 1
      10: 0 0 0 1 1
```

### nextCombination(a)

- aの「次に小さい」ビットパターンを求めたい
- aの偶奇で分けてみる

### aが偶数のとき

例
```
1 1 0 0 0
1 0 1 0 0
1 0 0 1 0
1 0 0 0 1
```

一般形
```
* 1 0「s個の0」
* 0 1「s個の0」
```

- `*100...0`の次に小さいのは`*010...0`
- 従って`a & -a`によりLSBから見て初めて1の部分だけを取り出し、それを1bit右シフトした値を引けばよい
- `a - (a & -a) / 2`

### aが奇数のとき

例
```
0 1 1 1 0 0 1 1 1
0 1 1 0 1 1 1 1 0
```

一般形

```
*「1 0」「s個0」「t個1」
*「0 1」「t個1」「s個0」
```

- まず「t個の1」を作る
- 「t個の1」に1を足せば`*01...1`→`*10...0`なので排他的論理和を取れば`011...1`
  - `b = a ^ (a + 1);`
    - Intelには`blsmsk(a) = a^(a-1)`という命令がある
  - この半分は「t個の1」
  - それをaから引くと「t個の1」がクリアされる ; `c = a - b / 2;`

```
a = *「1 0」「s個0」「t個1」
c = *「1 0」「s個0」「t個0」
```

- 目標は「0 1」「t個1」「s個0」なのでcから『1「s-1個の0」』を引けばよい
- `c & -c`で『*「1 0」』の1を取り出す
- それをt+1個右シフトすると作れる
  - bは「t個の1」なので+1すると『1「t個の0」』
  - b+1で割ればよい
  - それをcから引く
  - `c - (c & -c) / (b + 1)`

### まとめる

```
uint64_t nextCombination(uint64_t a)
{
  if (a & 1) {
    uint64_t b = a ^ (a + 1);
    uint64_t c = a - b / 2;
    return c - (c & -c) / (b + 1);
  } else {
    return a - (a & -a) / 2;
  }
}
```

- aが偶数のときは`b = a ^ (a + 1) = 1`
- よって`c = a - b / 2 = a`
- だから奇数のときに含まれる

最終形態
```
uint64_t nextCombination(uint64_t a)
{
  uint64_t b = a ^ (a + 1);
  uint64_t c = a - b / 2;
  return c - (c & -c) / (b + 1);
}
```

速度優先なら分岐する方がよい場合がある

### ループの終了条件

a=「0...01...1」のときcが0になるのでnextCombinationの結果が0になりループが終了する。

## MSBから見て最初に1が立った場所(bsr)

### x86の場合

- x86ならbsr(x)命令を使う
  - ただしx = 0のときbsrの結果は不定なので注意
  - ZF=1なのでそれを使って対応可能

### floatの指数部を取り出す

- x≠0のときy = bsr(x)とすると`1 << y`はxを超えない最大の2ベキ
- float x = [s:e:m](s:1bit, e:8bit, m:23bit)とするとx = (-1)<sup>s</sup>2<sup>e-127</sup>(1+m/2<sup>23</sup>)
- つまりeを取り出せばよい

### 浮動小数点数と整数のビット変換

C/C++のstrict aliasingを避けるためにmemcpyを使う

```
uint32_t f2u(float f)
{
  uint32_t u;
  memcpy(&u, &f, sizeof(u));
  return u;
}

float u2f(uint32_t u)
{
  float f;
  memcpy(&f, &u, sizeof(f));
  return f;
}

uint64_t d2u(double d)
{
  uint64_t u;
  memcpy(&u, &d, sizeof(u));
  return u;
}

double u2d(uint64_t u)
{
  double d;
  memcpy(&d, &u, sizeof(d));
  return d;
}
```

通常コンパイラの最適化によりmovなどのレジスタ移動命令に置き換わる

### ilog(x)

```
// same as bsr(x)
uint32_t ilog2(uint32_t x)
{
  assert(x != 0);
  return (f2u(x) >> 23) + 127;
}
```
