---
title: "準同型暗号CKKSその3 暗号化・復号と演算"
emoji: "🧮"
type: "tech"
topics: ["準同型暗号", "CKKS", "暗号化", "演算"]
published: true
---
## 初めに
今回は準同型暗号CKKSの暗号化・復号と、加算・乗算方法を説明します。
記事一覧は[準同型暗号CKKSその1 多項式環](https://zenn.dev/herumi/articles/ckks-ring-iso)

## 主な記号の復習
- $M$ : 4以上の2のべきの形の整数, $N:=M/2$
- $[\cdot]$ : 整数への丸め（多項式ならその係数）
- $R:=ℤ[X]/(X^N+1)$ : 整数係数の多項式を$X^N+1$で割った余りの多項式全体

整数$n$に対して$R_n$を、$R$の多項式の係数を$n$で割った余りとする多項式全体とします。$R_n:=(ℤ/nℤ)[X]/(X^N+1).$

## パラメータと乱数
CKKSでは様々なパラメータが登場します。
- $L$ : 乗算回数の上限
- $p$, $q_0$ : 適当な整数
- $q_l:=p^l q_0$ for $0 < l \le L.$ : $l$は暗号文のレベルを表す。とりあえず今回は固定としてください。

$L$は暗号文の乗算を何回できるかを示すパラメータです。
$p$や$q_0$は扱う暗号文の精度に関するパラメータです。
これらのパラメータは大きいほどよくなりますが、暗号文などが大きくなります。
$M$は安全性を示すセキュリティパラメータと$q_l$によって決まります。実際には1024, 2048, 4096などが使われます。

秘密鍵や暗号化に使う乱数がいろいろ登場します。これも様々なパラメータや分布によって決まるのですが、煩雑なのでここではばっさり省略します。
集合$S$からランダムに要素$a$を一つ選ぶことを$a ← S$と書きます。

## 鍵生成とR-LWE仮定
$\Set{-1,0,1}$の中から$N$個ランダムに選んでそれを係数とする多項式を$s \in R_{q_L}$とします。これが秘密鍵です。
$a ← R_{q_L}$と、係数が小さい乱数の$N$次多項式$e$を選びます。$b:=-as+e \in R_{q_L}$とします。$(b, a) \in (R_{q_L})^2$が公開鍵です。

もし、乱数$e$が無ければ$a, b$が公開されているので方程式$b=-as$は容易に解けて秘密鍵$s$が求まります。しかし乱数$e$があると適切なサイズのパラメータの元では$s$を求めるのが困難であると考えられています。
大雑把に言うと、そのような仮定をR-LWE(ring learning with errors)仮定といい、CKKSはR-LWE仮定の元で安全とされています。

## 暗号化
$m \in R$を平文、$pk:=(b,a)$を公開鍵とします。
$v$を$\Set{-1,0,1}$の中からランダムに選んで係数とした多項式、$e_0, e_1$を小さい係数のランダム多項式とします。
$Enc(m):=v \cdot pk + (m + e_0, e_1) \in (R_{q_L})^2$が暗号文です。ここで$(R_{q_L})^2$の掛け算や足し算は要素ごとにします。つまり
$Enc(m)=v(b, a)+(m+e_0, e_1)=(vb + m+e_0, va + e_1).$

やはりR-LWE仮定により、$a$と$va+e_1$から$v$は求められず、したがって$vb+m+e_0$と$b$から$m$は分かりません。

## 復号
レベル$l$の暗号文$c:=(c_0, c_1) \in (R_{q_l})^2$に対して秘密鍵$s$を使って$Dec(c):=c_0 + c_1 s \in R_{q_l}$とします。

$c=Enc(m)$のとき、$Dec(c)=m \bmod{q_l}$を確認しましょう。構成方法から$b=-as+e$, $c_0=vb + m+e_0$, $c_1=va+e_1$なので

$$
Dec(c)=(v(-as+e) + m+e_0)+(va+e_1)s=m+(ve+e_0+e_1s).
$$

ここで$v$, $e$, $e_0$, $e_1$, $s$はどれも小さい係数なので$(ve+e_0+e_1s)$も小さい係数の多項式です。
したがって、$Dec(c) \approx m$となり大体復号できました。このようにCKKSは誤差を伴う近似暗号です。

## 暗号文の加算
$m, m' \in R$の暗号文$c:=Enc(m)=(c_0,c_1)$, $c':=Enc(m')=(c'_0,c'_1)$について、$c+c'$を要素ごとの加算で定義します。

$$
c+c':=(c_0+c'_0,c_1+c'_1)
$$
すると

$$
\begin{align*}
c+c'&=(v \cdot pk + (m + e_0,e_1))+(v' \cdot pk + (m' + e'_0,e'_1))\\
&=(v+v')pk + ((m+m')+(e_0+e'_0), (v+v')a + (e_1+e'_1))\\
&=v'' pk + ((m+m')+e''_0, e''_1).
\end{align*}
$$

ただし$v'':=v+v'$, $e''_0:=e_0+e'_0$, $e''_1:=e_1+e'_1$. これらが小さい乱数なので、$c+c'$は$m+m'$の暗号文に近いです。したがって、

$$
Dec(c+c') \approx m+m'.
$$

これは暗号文の加算ができていることを意味します。

## 暗号文の乗算
前節の記号を用いて2個の暗号文$c, c' \in (R_{q_l})^2$の乗算を次の方法で定義します。

$$
cc':=(c''_0, c''_1, c''_2) := (c_0 c'_0, c_0 c'_1 + c_1 c'_0, c_1 c'_1) \in (R_{q_l})^3.
$$

乗算後の暗号文は$R_{q_l}$の要素3個になりました。復号するには$Dec(cc'):=c''_0+c''_1 s + c''_2 s^2$を使います。乗算前の暗号文の復号は$c_0+c_1 s$だったのに比べて項が1個増えています。
これが$mm'$に近いことを確認しましょう。

$$
Dec(cc')=(c_0 c'_0) + (c_0 c'_1 + c_1 c'_0)s + (c_1 c'_1)s^2=(c_0+c_1 s)(c'_0 + c'_1 s).
$$

$c_0+c_1 s = Dec(c) \approx m$, $c'_0 + c'_1 s=Dec(c') \approx m'$なので$Dec(cc') \approx mm'$となります。
ただし、誤差は加算のときよりもずっと大きくなっているので注意が必要です。このあたりの精密な評価は[論文](https://eprint.iacr.org/2016/421)を参照ください。
[ペアリングと内積計算可能なL2準同型暗号](https://zenn.dev/herumi/articles/pairing-l2he)で紹介した暗号も暗号文同士を掛け算すると暗号文の構造が大きくなってしまいました。残念ながらあちらはサイズを小さくできなかったのですが、CKKSは評価鍵というものを導入すると小さくできます。

## 評価鍵と乗算暗号文サイズの縮小
評価鍵$evk$を定義するために、新しく整数$P$というパラメータを導入します。
$a' ← R_{P q_L}$, $e'$を小さい乱数、$b':=(-a's + e' + P s^2) \bmod{P q_L}$として、$evk:=(b', a') \in (R_{P q_L})^2$とします。公開鍵$pk$と同じくR-LWE仮定により$b'$から秘密鍵$s$は求められません。
前節で作った乗算後の暗号文$(c_0, c_1, c_2)$に対して$(d_0, d_1):=(c_0, c_1) + [P^{-1} c_2 evk] \bmod{q_l}$とします。以下mod $q_l$で考えると

$$
\begin{align*}
d_0 &= c_0 + [P^{-1} c_2 (-a's + e' + P s^2)]=c_0 + c_2 s^2 + [P^{-1} c_2 (-a's+e')].\\
d_1 &=c_1 + [P^{-1} c_2 a'].
\end{align*}
$$

$d_0$が$c_0+c_2 s^2$と残りの形になっていることに注意してください。このようにして作った暗号文$(d_0, d_1)$を復号してみましょう。

$$
Dec((d_0, d_1))=d_0 + d_1 s = (c_0 + c_1 s+c_2 s^2) +[P^{-1}c_2(-a's+e')] + [P^{-1} c_2 a']s.
$$

右辺前半$c_0+c_1 s + c_2 s^2$は前節の$Dec(cc')$と同じなので$mm'$に近い値です。後半の値は整数丸めをしなければ$(P^{-1}c_2(-a's+e')) + (P^{-1} c_2 a')s=P^{-1}c_2 e'$なので、$P$を$c_2$の係数に比べて大きくとると丸めによる誤差を含めても小さい値です。よって、$Dec((d_0, d_1)) \approx mm'.$
改めて、$c:=(c_0, c_1)=Enc(m)$, $c':=(c'_0, c'_1)=Enc(m')$としたとき、

$$
\begin{align*}
c''_0&:=c_0 c'_0,\\
c''_1&:=c_0 c'_1 + c_1 c'_0,\\
c''_2&:=c_1 c'_1,\\
(d_0,d_1)&:=(c''_0, c''_1)+[P^{-1}c''_2 evk] \bmod{q_l}
\end{align*}
$$
として暗号文同士の乗算を$c c':=(d_0,d_1)$で定義します。

なお、[CKKSの平文空間とエンコード・デコード](https://zenn.dev/herumi/articles/ckks-encoding#ckks%E3%81%AE%E5%B9%B3%E6%96%87%E7%A9%BA%E9%96%93%E3%81%A8%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89%E3%83%BB%E3%83%87%E3%82%B3%E3%83%BC%E3%83%89)で説明したように$C^{N/2}$の元をエンコードするときにスケール因子$Δ$倍しています。
したがって、乗算後は$Δ^2$が掛かっていることに注意してください。

## リスケール
レベル$l$の暗号文$c:=(c_0,c_1) \in (R_{q_l})^2$をレベル$l' < l$に変換します。リスケールすると演算精度を制御しつつ暗号文サイズを小さくできます。スケール因子$Δ$とは違うものなので注意してください。
$c'_i:=[c_i/p^{l-l'}]$と各要素を$p^{l-l'}$で割って整数に丸めるだけです。$Rs_{l→l'}(c):=(c'_0,c'_1) \in (R_{q_l'})^2$がリスケーリングです。

## まとめ
CKKSの暗号化と復号処理を紹介し、暗号文同士の加算と乗算も解説しました。
乗算すると暗号文が要素3個になるのですが、評価鍵を用いて元の要素2個の暗号文に変換できます。
