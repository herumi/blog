---
title: "定数除算最適化再考4 更なる高速化"
emoji: "📖"
type: "tech"
topics: ["整数", "除算", "逆数乗算"]
published: true
---
## 初めに
整数の定数除算最適化の続きです。
今回は前回提示した
```cpp
uint32_t udiv7(uint32_t x) {
    return x / 7;
}
```
の更なる改善をします。

## [前回まで](https://zenn.dev/herumi/articles/const-div-revised3)のまとめ
符号なし32ビット整数 $x$ の $d$ による定数整数除算を $x // d = (x c)>>a$ と乗算と論理右シフトで置き換える手法の考察です。
$c$ が33ビット整数になるとき既存コンパイラよりより方法として二つ紹介しました。

一つは64ビット×64ビット=128ビット乗算命令を使ってから128ビットシフトをするmul64 + sft、もう一つは32ビット×32ビット=64ビット乗算命令を使うのは既存コンパイラと同じだけどその後64ビットレジスタを使うmul32です。

対象コードをインライン展開し、lpN回実行するのにかかった時間を測定すると、

**Xeon w9-3495X** - 処理時間（単位: msec）

| 方式 | lp=1 | lp=2 | lp=3 |lat.|
|---|---:|---:|---:|---:|
| clang | 60.62 | 239.26 | 452.89 |196.14|
| mul64+sft | 42.61 | 219.96 | 408.95 |183.17|
| mul32 | 52.03 | 195.53 | 363.37 |155.67|

**Apple M4 Pro**

| 方式 | lp=1 | lp=2 | lp=3 |lat.|
|---|---:|---:|---:|---:|
| clang | 40.94 | 267.47 | 511.61 |235.34|
| mul64+sft | 33.29 | 201.42 | 382.63 |174.67|
| mul32 | 33.33 | 223.04 | 423.37 |195.02|

となりました。

Apple M4ではmul64+sftが速いが、Xeonではmul32のほうがレイテンシはよい（lpを増やしたときの増分が小さい）ことがわかりました。
これは、Xeonでは128ビットのシフト命令shrdがmulと同じぐらいの時間がかかるせいです。

**Skylake Xアーキテクチャー: レイテンシとスループット**

| 命令 | レイテンシ | スループット |
|---|---:|---:|
| add/sub | 1 | 0.25 |
| shr | 1 | 0.5 |
| imul | 3 | 1 |
| shrd | 3 | 1 |

# shrdを回避する
せっかく64ビット×64ビット=128ビット乗算命令を使っているのにshrdが足を引っ張るのは勿体ないです。
そこでshrdを使わない方法を考えたところ、次の方法を思いつきました。

$$
x//d=(x c)//2^a = (x c 2^{64-a})//2^{64}
$$

```cpp
uint32_t udiv7(uint32_t x) {
  typedef __attribute__((mode(TI))) unsigned int uint128_t;
  uint128_t cs = uint128_t(c) << (64 - a);
  return (uint32_t)((x * cs) >> 64);
}
```
$a$ ビット右シフトするところで、最初から定数乗数 $c$ を $64-a$ ビット左シフトしておけば、乗算後の値を64ビット右シフトしたのと同じです。なお、値の構成法からオーバーフローしないことは分かっています（そうでないとこの変形はできない）。そして、128ビット値の64ビット右シフトは上位64ビットのレジスタそのものです。

たとえば上記コードを`clang -O3 -march=native`でコンパイルすると

```nasm
udiv7:
    mov edx, edi
    movabs  rax, 0x24924924a0000000
    mulx    rax, rax, rax
```

となります。レジスタのコピーや即値設定を除けば `mul` 命令一つで実行できます。
Apple M4でも即値設定を除いて `umulh` 命令一つになります。

```nasm
div7a:
    // 即値設定
    mov x8, #2684354560
    mov w9, w0
    movk    x8, #18724, lsl #32
    movk    x8, #9362, lsl #48
    // 乗算
    umulh   x0, x9, x8
    ret
```

元々の除算コード

```cpp
uint32_t div7(uint32_t x) { return x / 7; }
```

に対してコンパイラが生成するコード

```nasm
div7org:
    // 即値設定
    mov w8, #18725                      // =0x4925
    movk    w8, #9362, lsl #16
    // 乗算
    umull   x8, w0, w8
    // 残りの処理
    lsr x8, x8, #32
    sub w9, w0, w8
    add w8, w8, w9, lsr #1
    lsr w0, w8, #2
    ret
```

に比べてずっとシンプルになりました。実行時間も当然速くなります。

## ベンチマーク
前節のベンチマークの結果に、新しい手法(mul64)を追加しました。

**Xeon w9-3495X: 処理時間（単位: msec）**
| 方式 | lp=1 | lp=2 | lp=3 |
|---|---:|---:|---:|
| clang | 60.62 | 239.26 | 452.89 |
| mul64+sft | 42.61 | 219.96 | 408.95 |
| mul32 | 52.03 | 195.53 | 363.37 |
| mul64 | 43.61 | 158.61 | 283.94 |

**Apple M4 Pro: 処理時間（単位: msec）**

| 方式 | lp=1 | lp=2 | lp=3 |
|---|---:|---:|---:|
| clang | 40.94 | 267.47 | 511.61 |
| mul64+sft | 33.29 | 201.42 | 382.63 |
| mul32 | 33.33 | 223.04 | 423.37 |
| mul64 | 30.21 | 156.40 | 289.56 |

コンパイラの生成コードよりも40%程度、レイテンシはそれ以上速くなっています。
このあたりの話は2026年 暗号と情報セキュリティシンポジウム[SCIS2026](https://www.iwsec.org/scis/2026/)でも紹介する予定です｡
