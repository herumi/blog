---
title: "有限体の実装1（減算）"
emoji: "🧮"
type: "tech"
topics: ["有限体", "sub", "x64"]
published: false
---
## 初めに

前回まで[多倍長整数の実装1（C/C++）](https://zenn.dev/herumi/articles/bitint-01-cpp)からの一連の記事で多倍長整数演算の実装の紹介をしました。今回から有限体の実装の紹介をします。有限体で利用する素数は256bit～512bitを想定しています。

## 有限体の実装一覧

- [有限体の実装1（減算）（この記事）](https://zenn.dev/herumi/articles/finite-field-01-sub)

## 有限体の復習

有限体についてはまず、[楕円曲線暗号のPythonによる実装その1（有限体とECDH鍵共有）](https://zenn.dev/herumi/articles/sd202203-ecc-1#%E6%9C%89%E9%99%90%E4%BD%93)をごらんください。
ごく簡単に復習すると$p$を素数としたとき、$0$以上$p$未満の整数の集合を$F_p$と書き、有限体と呼びます。

$$
F_p = \{0, 1, 2, ..., p-1\}.
$$

有限体は通常の四則演算と似た性質を持つ四則演算を定義できます。「似た性質」とは$(a+b)+c=a+(b+c)$, $a(bc) = (ab)c$とか$a(b + c) = ab + ac$といった結合法則や分配法則を指します。
四則演算のうち、加算、減算、乗算については$x, y \in F_p$について、$x$, $y$を整数と思って加減乗算したあと$p$で割ったものです。

$$
（有限体での）x + y = （整数での）x + y \mod p.\\
（有限体での）x - y = （整数での）x - y \mod p.\\
（有限体での）x \times y = （整数での）x \times y \mod p.
$$

ここで$\mod p$は$p$で割った余り（$0$以上$p$未満の整数）を表します。

## 有限体の加減算の実装

まず、比較的容易な加減算の実装について詳細に入ります。
「$p$で割った余り」を求める操作は通常重たいです。有限体の演算は極限まで高速化したいのでそのような操作は極力避けたいです。

元の$x$, $y$は$0 \le x, y \le p-1$なのですから、$x+y$の範囲は$0 \le x+y \le 2p-2$です。
もし$z=x+y$が$p$以上なら$z$から$p$を引くと$0 \le z-p \le p-2$となります。これは$x+y$を$p$で割った余りに一致します。すなわち

```python
def add(x, y):
  z = x + y
  if z >= p:
    z -= p
  return z
```

とすると結果は常に$F_p$の元（要素）となり、有限体の加算が実装できたことになります。

