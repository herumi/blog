# ビット操作あれこれ

## `x & -x`

```
for (int x = 0; x < 20; x++) {
    printf("%d %d\n", x, x & -x);
}
```
結果
```
0 0
1 1
2 2
3 1
4 4
5 1
6 2
7 1
8 8
9 1
10 2
11 1
12 4
13 1
14 2
15 1
16 16
17 1
18 2
19 1
```

### `x & -x`の役割

- LSB(一番小さい右のビット)から見て最初に1が立った部分のみ1にしてそれ以外は0にする
- 0のときは0

### 理由
- `-x = ~x + 1`である(intが2の補数のとき - x64やARMなど)
- `~x`はビット反転
- `+ 1`は1を足す

### 「1を足す」とは

```
0 000000
1 000001
2 000010
3 000011
4 000100
5 000101
6 000110
7 000111
8 001000
9 001001
...
```

- 右から0個以上連続する1(これを`1...1`と書く)の左に0があると見なす
  - `*01...1` ; *は任意個のなんでもよいビットパターン
  - 任意の値はこの形とみなせる
- `+1`はこれを`*10...0`に変換する操作
  - `0` → `1` ; 0個連続する1
  - `1` → `10` ; 1個連続する1
  - `011` → `100` ; 2個連続する1
  - `1...1`(全部1) → `0...0` ; 1はオーバーフローして消える

元のxを「*10...0」の形とみなす(0...0は0個以上連続する0なので任意のxはこの形とみなせる)

- `x = *10...0`
- `~x = ~*01...1`
- `-x = ~x+1 = ~*10...0`
- `x & -x`
  - 上位ビットは`* & ~*`なので0
  - 下位ビットは`10...0`
  - よってLSBから見て最初に1が立った部分だけが残り、後は0

### blsi(x)

x86には`blsi(x) = x & -x`という命令がある(BMI1 : Haswell以降)

## ビット組み合わせのパターン

[サンプルコード](https://github.com/herumi/misc/blob/master/combination2.cpp)

```
uint64_t nextCombination(uint64_t a)
{
  uint64_t b = a ^ (a + 1);
  uint64_t c = a - b / 2;
  return c - (c & -c) / (b + 1);
}

int n = 5;
int k = 3;
int a = ((1 << (n - k)) - 1) << k; // 5個の内2個1が立っている
do {
  putB(n, a);
} while (a = nextCombination(a));
```

結果
```
       1: 1 1 0 0 0
       2: 1 0 1 0 0
       3: 1 0 0 1 0
       4: 1 0 0 0 1
       5: 0 1 1 0 0
       6: 0 1 0 1 0
       7: 0 1 0 0 1
       8: 0 0 1 1 0
       9: 0 0 1 0 1
      10: 0 0 0 1 1
```

### nextCombination(a)

- aの「次に小さい」ビットパターンを求めたい
- aの偶奇で分けてみる

### aが偶数のとき

例
```
1 1 0 0 0
1 0 1 0 0
1 0 0 1 0
1 0 0 0 1
```

一般形
```
入力: 1 0「s個の0」
出力: 0 1「s個の0」
```

- `*100...0`の次に小さいのは`*010...0`
- 従って`a & -a`によりLSBから見て初めて1の部分だけを取り出し、それを1bit右シフトした値を引けばよい
- `a - (a & -a) / 2`

### aが奇数のとき

例
```
入力: 0 1 1 1 0 0 1 1 1
出力: 0 1 1 0 1 1 1 1 0
```

一般形

```
入力: 1 0」「s個0」「t個1」
出力:「0 1」「t個1」「s個0」
```

- まず「t個の1」を作る
- 「t個の1」に1を足せば`*01...1`→`*10...0`なので排他的論理和を取れば`011...1`
  - `b = a ^ (a + 1);`
    - Intelには`blsmsk(a) = a^(a-1)`という命令がある
  - この半分は「t個の1」
  - それをaから引くと「t個の1」がクリアされる ; `c = a - b / 2;`

```
a = *「1 0」「s個0」「t個1」
c = *「1 0」「s個0」「t個0」
```

- 目標は「0 1」「t個1」「s個0」なのでcから『1「s-1個の0」』を引けばよい
- `c & -c`で『*「1 0」』の1を取り出す
- それをt+1個右シフトすると作れる
  - bは「t個の1」なので+1すると『1「t個の0」』
  - b+1で割ればよい
  - それをcから引く
  - `c - (c & -c) / (b + 1)`

### まとめる

```
uint64_t nextCombination(uint64_t a)
{
  if (a & 1) {
    uint64_t b = a ^ (a + 1);
    uint64_t c = a - b / 2;
    return c - (c & -c) / (b + 1);
  } else {
    return a - (a & -a) / 2;
  }
}
```

- aが偶数のときは`b = a ^ (a + 1) = 1`
- よって`c = a - b / 2 = a`
- だから奇数のときに含まれる

最終形態
```
uint64_t nextCombination(uint64_t a)
{
  uint64_t b = a ^ (a + 1);
  uint64_t c = a - b / 2;
  return c - (c & -c) / (b + 1);
}
```

速度優先なら分岐する方がよい場合がある

### ループの終了条件

a=「0...01...1」のときcが0になるのでnextCombinationの結果が0になりループが終了する。

### bsr(x)

MSBから見て最初に1が立った場所を返すx86/x64の命令

- x = 0のときbsrの結果は不定なので注意
- ZF=1なのでそれを使って対応可能

組み込み関数

- sizeof(x) = 4のとき
  - Windowsなら`_BitScanReverse(x)`
  - gcc系なら`__builtin_clz(x) ^ 0x1f`
- sizeof(x) = 8のとき
  - Windowsなら`_BitScanForward64(x)`
  - gcc系なら`__builtin_clzll(x) ^ 0x3f`

### nextCombinationの割り算を減らす

`b = a^(a+1)`のとき`b+1`で割るということはbsr(b + 1)で右シフトすればよい

```
uint64_t nextCombination(uint64_t a)
{
  uint64_t b = a ^ (a + 1);
  uint64_t c = a - b / 2;
  return c - (c & -c) >> bsr(b + 1);
}
```

## MSBから見て最初に1が立った場所

- bsr(x)を使えばよい
- それ以外の方法

### floatの指数部を取り出す方法

- x≠0のときy = bsr(x)とすると`1 << y`はxを超えない最大の2ベキ
- float x = [s:e:m](s:1bit, e:8bit, m:23bit)とするとx = (-1)<sup>s</sup>2<sup>e-127</sup>(1+m/2<sup>23</sup>)
- つまりeを取り出せばよい

### 浮動小数点数と整数のビット変換

C/C++のstrict aliasingを避けるためにmemcpyを使う

```
uint32_t f2u(float f)
{
  uint32_t u;
  memcpy(&u, &f, sizeof(u));
  return u;
}

float u2f(uint32_t u)
{
  float f;
  memcpy(&f, &u, sizeof(f));
  return f;
}

uint64_t d2u(double d)
{
  uint64_t u;
  memcpy(&u, &d, sizeof(u));
  return u;
}

double u2d(uint64_t u)
{
  double d;
  memcpy(&d, &u, sizeof(d));
  return d;
}
```

通常コンパイラの最適化によりmovなどのレジスタ移動命令に置き換わる

### ilog(x)

`bsr(x) = int(log2(x))`

```
// same as bsr(x)
uint32_t ilog2(uint32_t x)
{
  assert(x != 0);
  return (f2u(x) >> 23) + 127;
}
```

## doubleを使った方法

[@mkashiさん](https://twitter.com/mkashi/status/1434847564256268291)

```
uint32_t bsr_shift(uint32_t x)
{
  double a = 4503599627370497. * x;
  double b = 0.99999999999999989 * a;
  return (uint32_t)(a - b);
}
```

例
```
bsr_shift(0000000d)=00000008
bsr_shift(0000000e)=00000008
bsr_shift(0000000f)=00000008
bsr_shift(00000010)=00000010
bsr_shift(00000011)=00000010
bsr_shift(00003039)=00002000
bsr_shift(0098967f)=00800000
```

- M = 2^52とすると
- A = 4503599627370497. = M + 1 = M(1 + 1/M)
- B = 0.99999999999999989 = (1/2)(1 + (M-1)/M) = 1 - 1/2M

### 仕組み

- x = 2^e(1 + m/M)とする
  - eは指数
  - m ∈ [0, M-1]

- a = M(1 + 1/M) 2^e(1 + m/M) = (2^e M)(1 + (m+1)/M + m/M^2)
  - m/M^2の丸め
    - m/M^2 >= 1/2Mなら1そうでないなら0
    - c = (m >> 51) & 1
  - a = (2^e M)(1 + (m+1+c)/M)

- B倍の操作
  - x = 2^e(1 + m/M)とすると
  - Bx = 2^e(1 + m/M)(1 - 1/2M) = 2^e(1 + (2m-1)/2M - m/2M^2)
    - 常に m/2M^2< 1/2Mなので丸められて消える
  - Bx = 2^e(1 + (m - 1/2)/M) = 2^e(1 + (m-1)/M)

よって
- b = Ba = (2^e M)(1 + (m+c)/M)
- a - b = (2^e M)(1 + (m+1+c)/M - 1 - (m+c)/M) = 2^e M(1/M) = 2^e
  - 2ベキだけが残る

### 境界

上記関数はuint64_tでは破綻する

- 仕組みの説明の限界(ほころび)
  - x = M - 1 = (1<<52)-1のときa = (2^e M)(1 + M/M + m/M^2) = (2^e M)2(1 + m/2M^2)
  - c = (m >> 51) & 1 = 1だけども繰り上がらないのが正しい
  - ただしbsr_shift(x)自体は正しく動作する

- uint64_t→doubleの限界
  - x = (1<<54) - 1のときdoubleにcastした時点で(1<<54)になっているのでbsr_shiftも正しく動かない

## 正の数の偶数丸め

0以上(1<<31)未満な浮動小数点数xに対してM = 1<<52を足して引くと偶数丸め(.5は偶数方向に丸められる)ができる

```
double myround(double x)
{
  double c = 1ull << 52;
  return x + c - c;
}

myround(0.4) = 0
myround(0.5) = 0
myround(0.6) = 1
myround(1.3) = 1
myround(1.5) = 2
myround(12345.6) = 12346
myround(4294967292.9) = 4294967293

```
x86での丸め命令は[x86/x64における小数から整数への丸め処理命令の変遷](https://blog.cybozu.io/entry/2017/08/15/080000)参照
